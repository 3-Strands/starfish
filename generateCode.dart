import 'dart:io';

import 'package:starfish/src/generated/starfish.pb.dart';
import 'package:protobuf/protobuf.dart';

part 'fieldMasks.dart';

abstract class Storage {
  const Storage();

  String toCreateCode(String keyCode, String modelCode);
  String toUpdateCode(String keyCode, String modelCode);
  String toDeleteCode(String keyCode, String modelCode);
}

class BoxStorage extends Storage {
  const BoxStorage(this.name);

  final String name;

  @override
  String toCreateCode(String keyCode, String modelCode) {
    return 'globalHiveApi.$name.put($keyCode, $modelCode)';
  }

  @override
  String toUpdateCode(String keyCode, String modelCode) =>
      toCreateCode(keyCode, modelCode);

  @override
  String toDeleteCode(String keyCode, String modelCode) {
    return 'globalHiveApi.$name.delete($keyCode)';
  }
}

enum ReferenceType {
  fullModel,
  modelKey,
}

class Reference {
  Reference(this.model, this.field, this.type);

  final Model model;
  final String field;
  final ReferenceType type;
}

class ReferenceStorage extends Storage {
  const ReferenceStorage(this.references);

  final Map<String, Reference> references;

  @override
  String toCreateCode(String keyCode, String modelCode) {
    return references.entries.map((entry) {
      final referringField = entry.key;
      final refersTo = entry.value;
      switch (refersTo.type) {
        case ReferenceType.fullModel:
          final box = refersTo.model.storage as BoxStorage;
          return 'globalHiveApi.${box.name}.get($modelCode.$referringField)!.${refersTo.field}.add($modelCode)';
        case ReferenceType.modelKey:
          return '';
      }
    }).join(';\n');
  }

  @override
  String toUpdateCode(String keyCode, String modelCode) {
    return references.entries.map((entry) {
      final referringField = entry.key;
      final refersTo = entry.value;
      switch (refersTo.type) {
        case ReferenceType.fullModel:
          final box = refersTo.model.storage as BoxStorage;
          return 'globalHiveApi.${box.name}.resave($modelCode.$referringField)';
        case ReferenceType.modelKey:
          return '';
      }
    }).join(';\n');
  }

  @override
  String toDeleteCode(String keyCode, String modelCode) {
    return references.entries.map((entry) {
      final referringField = entry.key;
      final refersTo = entry.value;
      switch (refersTo.type) {
        case ReferenceType.fullModel:
          final box = refersTo.model.storage as BoxStorage;
          return 'globalHiveApi.${box.name}.edit($modelCode.$referringField, (item) => item.${refersTo.field}.remove($modelCode))';
        case ReferenceType.modelKey:
          return '';
      }
    }).join(';\n');
  }
}

abstract class ModelKey {
  bool isKey(String field);
  String toCode(String base);

  bool get isAutoGenerated;

  factory ModelKey.single(String field, {bool auto = false}) {
    return ModelKeySingle(field, isAutoGenerated: auto);
  }

  factory ModelKey.compound(List<String> fields) {
    return ModelKeyCompound(fields);
  }

  static ModelKey id = ModelKey.single('id', auto: true);
}

class ModelKeySingle implements ModelKey {
  ModelKeySingle(this.field, {this.isAutoGenerated = false});

  final String field;
  final bool isAutoGenerated;

  @override
  bool isKey(String field) => field == this.field;

  @override
  String toCode(String base) => '$base.$field';
}

class ModelKeyCompound implements ModelKey {
  ModelKeyCompound(this.fields);

  final List<String> fields;

  @override
  bool isKey(String field) => fields.contains(field);

  @override
  bool get isAutoGenerated => false;

  @override
  String toCode(String base) =>
      '\'${fields.map((field) => '\${$base.$field}').join(':')}\'';
}

class Field {
  Field({
    required this.name,
    required this.protoName,
    required this.type,
    required this.isIterable,
  });
  final String name;
  final String protoName;
  final String type;
  final bool isIterable;
}

class Model {
  Model(
    this.message, {
    required this.key,
    required this.typeId,
    required this.storage,
    this.readonlyFields = const {},
    this.editableFields,
    this.createUpdateRequest,
    this.deleteRequest,
  });

  final GeneratedMessage message;
  final ModelKey key;
  final int typeId;
  final Storage storage;
  final Set<String> readonlyFields;
  final List<String>? editableFields;
  final GeneratedMessage? createUpdateRequest;
  final GeneratedMessage? deleteRequest;

  String get name => message.runtimeType.toString();

  static Set<String> _globalReadOnlyFields = {
    'editHistory',
    'dateCreated',
    'dateUpdated',
    'creatorId',
  };

  String makeDeltaCode() {
    final classBuffer = StringBuffer();
    _generateCreateDelta(classBuffer);
    classBuffer.writeln();
    _generateUpdateDelta(classBuffer);
    classBuffer.writeln();
    _generateDeleteDelta(classBuffer);
    return classBuffer.toString();
  }

  String makeAdapterCode() {
    final classBuffer = StringBuffer();

    classBuffer.writeln('''
      class ${name}Adapter extends _GrpcAdapter<$name> {
        @override
        int get typeId => $typeId;

        @override
        $name create() => $name.create();
      }
    ''');

    return classBuffer.toString();
  }

  // bool _isReadOnly(String field) =>
  //     _globalReadOnlyFields.contains(field) ||
  //     readonlyFields.contains(field) ||
  //     key.isKey(field);

  bool _isCreatable(String field) => !(_globalReadOnlyFields.contains(field) ||
      readonlyFields.contains(field));

  List<Field> get _fields {
    return message.info_.fieldInfo.values.map((field) {
      // if (field.name == 'dateDue') {
      //   // print(field.);
      // }
      final type = field.isRepeated
          ? field.makeDefault!().runtimeType.toString().substring(2)
          : field.type == PbFieldType.OS
              ? 'String'
              : field.type == PbFieldType.OB
                  ? 'bool'
                  : field.isGroupOrMessage
                      ? field.makeDefault!().runtimeType.toString()
                      : field.isEnum
                          ? field.enumValues![0].runtimeType.toString()
                          : 'dynamic';
      return Field(
        name: field.name,
        protoName: field.protoName,
        type: type,
        isIterable: field.isRepeated,
      );
    }).toList();
  }

  bool get isEditable => editableFields != null;

  List<Field> get _creatableFields =>
      _fields.where((field) => _isCreatable(field.name)).toList();

  void _generateCreateDelta(StringBuffer classBuffer) {
    if (createUpdateRequest == null) {
      classBuffer.writeln('// $name is not creatable');
      return;
    }

    final className = '${name}CreateDelta';

    classBuffer.writeln('class $className extends DeltaBase {');

    classBuffer.writeln('  $className({');

    final fields = _creatableFields;

    for (final field in fields) {
      classBuffer.writeln('    this.${field.name},');
    }

    classBuffer.writeln('  });');
    classBuffer.writeln();

    for (final field in fields) {
      classBuffer.writeln('  final ${field.type}? ${field.name};');
    }

    classBuffer.writeln();
    classBuffer.writeln('''
      @override
      bool apply() {
        final model = $name(
    ''');

    for (final field in fields) {
      classBuffer.writeln('${field.name}: ${field.name},');
    }

    classBuffer.writeln('''
        );
        ${storage.toCreateCode(key.toCode('model'), 'model')};
        return true;
      }
    ''');

    classBuffer.writeln('}');
  }

  void _generateUpdateDelta(StringBuffer classBuffer) {
    final editableFields = this.editableFields;

    if (editableFields == null || createUpdateRequest == null) {
      classBuffer.writeln('// $name is not updatable');
      return;
    }
    final className = '${name}UpdateDelta';

    classBuffer.writeln('class $className extends DeltaBase {');

    classBuffer.writeln('$className(this._model, {');

    final fields = _fields
        .where((field) => editableFields.contains(field.protoName))
        .toList();
    assert(fields.length == editableFields.length,
        'FieldMask definition not aligned with model definition for $name');

    for (final field in fields) {
      classBuffer.writeln('this.${field.name},');
    }

    classBuffer.writeln('});');
    classBuffer.writeln();

    classBuffer.writeln('final $name _model;');
    for (final field in fields) {
      classBuffer.writeln('final ${field.type}? ${field.name};');
    }

    classBuffer.writeln();
    classBuffer.writeln('''
      @override
      bool apply() {
        final updateMask = <String>[];
    ''');

    for (final field in fields) {
      final comparison = field.isIterable
          ? '!listsAreSame(${field.name}!, _model.${field.name})'
          : '${field.name} != _model.${field.name}';
      classBuffer.writeln('''
        if (${field.name} != null && $comparison) {
          ${field.isIterable ? '''_model.${field.name}
            ..clear()
            ..addAll(${field.name}!);''' : '_model.${field.name} = ${field.name}!;'}
          updateMask.add('${field.protoName}');
        }
      ''');
    }

    classBuffer.writeln('''
      if (updateMask.isNotEmpty) {
        ${storage.toUpdateCode(key.toCode('_model'), '_model')};
        return true;
      }
      return false;
    }
    ''');

    classBuffer.writeln('}');
  }

  void _generateDeleteDelta(StringBuffer classBuffer) {
    if (deleteRequest == null) {
      classBuffer.writeln('// $name is not deletable');
      return;
    }
    final className = '${name}DeleteDelta';

    classBuffer.writeln('class $className extends DeltaBase {');

    classBuffer.writeln('$className(this._model);');

    classBuffer.writeln();

    classBuffer.writeln('final $name _model;');

    classBuffer.writeln();
    classBuffer.writeln('''
      @override
      bool apply() {
        ${storage.toDeleteCode(key.toCode('_model'), '_model')};
        return true;
      }
    ''');

    classBuffer.writeln('}');
  }
}

void main() {
  final materialModel = Model(
    Material(),
    key: ModelKey.id,
    typeId: 5,
    storage: BoxStorage('material'),
    readonlyFields: {
      'languages',
      'feedbacks',
    },
    editableFields: _kMaterialFieldMask,
    createUpdateRequest: CreateUpdateMaterialsRequest(),
    deleteRequest: DeleteMaterialRequest(),
  );

  final actionModel = Model(
    Action(),
    key: ModelKey.id,
    typeId: 4,
    storage: BoxStorage('action'),
    editableFields: _kActionFieldMask,
    createUpdateRequest: CreateUpdateActionsRequest(),
    deleteRequest: DeleteActionRequest(),
  );

  final groupModel = Model(
    Group(),
    key: ModelKey.id,
    typeId: 12,
    storage: BoxStorage('group'),
    readonlyFields: {
      'languages',
    },
    editableFields: _kGroupFieldMask,
    createUpdateRequest: CreateUpdateGroupsRequest(),
  );

  final userModel = Model(
    User(),
    key: ModelKey.id,
    typeId: 16,
    storage: BoxStorage('user'),
    editableFields: _kUserFieldMask,
    createUpdateRequest: CreateUpdateUserRequest(),
  );

  final models = <Model>[
    Model(
      Country(),
      key: ModelKey.id,
      typeId: 0,
      storage: BoxStorage('country'),
    ),

    Model(
      Language(),
      key: ModelKey.id,
      typeId: 1,
      storage: BoxStorage('language'),
    ),

    Model(
      GroupUser(),
      key: ModelKey.compound(['userId', 'groupId']),
      typeId: 3,
      storage: ReferenceStorage({
        'groupId': Reference(groupModel, 'users', ReferenceType.fullModel),
        'userId': Reference(userModel, 'groups', ReferenceType.fullModel),
      }),
      editableFields: _kGroupUserFieldMask,
      createUpdateRequest: CreateUpdateGroupUsersRequest(),
      deleteRequest: GroupUser(),
    ),

    actionModel, // 4

    materialModel, // 5

    Model(
      MaterialFeedback(),
      key: ModelKey.id,
      typeId: 6,
      storage: ReferenceStorage({
        'materialId':
            Reference(materialModel, 'feedbacks', ReferenceType.fullModel),
      }),
      createUpdateRequest: CreateMaterialFeedbacksRequest(),
    ),

    Model(
      MaterialTopic(),
      key: ModelKey.id,
      typeId: 9,
      storage: BoxStorage('materialTopic'),
    ),

    Model(
      MaterialType(),
      key: ModelKey.id,
      typeId: 10,
      storage: BoxStorage('materialType'),
    ),

    groupModel, // 12

    Model(
      ActionUser(),
      key: ModelKey.compound(['actionId', 'userId']),
      typeId: 15,
      storage: ReferenceStorage({
        'userId': Reference(userModel, 'actions', ReferenceType.fullModel),
      }),
      editableFields: _kActionUserFieldMask,
      createUpdateRequest: CreateUpdateActionUserRequest(),
    ),

    userModel, // 16
  ];

  final deltaContents = '''
  // GENERATED CODE - DO NOT MODIFY BY HAND

  part of 'deltas.dart';

  ${models.map((model) => model.makeDeltaCode()).join('\n')}
  ''';

  File('lib/src/deltas.g.dart').writeAsString(deltaContents);

  final adapterContents = '''
  // GENERATED CODE - DO NOT MODIFY BY HAND

  part of 'grpc_adapters.dart';

  ${models.map((model) => model.makeAdapterCode()).join('\n')}
  ''';

  File('lib/src/grpc_adapters.g.dart').writeAsString(adapterContents);
}
